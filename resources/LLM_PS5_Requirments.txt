GENERAL POWERSHELL REQUIREMENTS (APPLY TO ALL FUNCTIONS)

1) COMPATIBILITY
   - MUST run on Windows PowerShell 5/5.1 and PowerShell 7+ on Windows/macOS/Linux.

2) AUTOMATIC / RESERVED VARIABLES (PS5–PS7)
   - Do not read/write/compare or shadow PowerShell automatic/reserved vars (any casing). Examples (not exhaustive): $_, $PSItem, $args/$Args, $IsWindows/$IsMacOS/$IsLinux, $Error, $pid, $PID, $LASTEXITCODE, $Matches, $home, $PSBoundParameters, $PSScriptRoot, $MyInvocation. Do not name parameters/locals like these (no "Args", "IsWindows", "Error", etc.).

3) EXTERNAL TOOLS
   - IF an external tool is required (e.g., dotnet, robocopy), THEN fail fast with a clear, actionable error when it is missing.

4) NAMING 
   - USE ONLY PS5/5.1 approved verbs.
   - PREFER singular nouns (plural may be an alias, not the primary noun).

5) SHOULDPROCESS / PIPELINE
   - DO NOT include SupportsShouldProcess; DO NOT implement -WhatIf or -Confirm.
   - DO NOT use ValueFromPipeline or ValueFromPipelineByPropertyName.

6) FLAGS & POLICY PARAMETERS
   - AVOID default-true switches for policy/behavior.
   - USE [ValidateSet()] string parameters instead (e.g., InstallationPolicy 'Trusted'|'Untrusted', State 'Enabled'|'Disabled').

7) ERROR BEHAVIOR
   - ASSUME caller may set $ErrorActionPreference = 'Stop'.
   - USE try/catch only where it adds value; rethrow with concise, actionable messages.

8) OUTPUT & LOGGING
   - EMIT Write- or _Write-StandardMessage ONLY for key actions (created X, added/removed Y, enabled/disabled Z, updated trust). Keep minimal and consistent.
   - Format the Write function implement a inline helper function for it suggested format.
    function _Write-StandardMessage {
        [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")]
        # This function has exceptions from the rest of any ruleset.
        [CmdletBinding()]
        param(
            [Parameter(Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [string]$Message,
            [Parameter(Mandatory=$false)]
            [ValidateSet('TRC','DBG','INF','WRN','ERR','FTL')]
            [string]$Level = 'INF',
            [Parameter(Mandatory=$false)]
            [ValidateSet('TRC','DBG','INF','WRN','ERR','FTL')]
            [string]$MinLevel
        )
        # Resolve MinLevel from global 'ConsoleLogMinLevel' if not passed; default to 'INF' when missing/empty (StrictMode-safe).
        if (-not $PSBoundParameters.ContainsKey('MinLevel')) { $gv = Get-Variable -Name 'ConsoleLogMinLevel' -Scope Global -ErrorAction SilentlyContinue; if ($null -ne $gv -and $null -ne $gv.Value -and -not [string]::IsNullOrEmpty([string]$gv.Value)) { $MinLevel = [string]$gv.Value } else { $MinLevel = 'INF' } }
        $sevMap = @{ TRC=0; DBG=1; INF=2; WRN=3; ERR=4; FTL=5 }
        $lvl = $Level.ToUpperInvariant() ; $min = $MinLevel.ToUpperInvariant() ; $sev = $sevMap[$lvl] ; $gate= $sevMap[$min]
        # Auto-escalate requested errors to meet strict MinLevel (e.g., MinLevel=FTL)
        if ($sev -ge 4 -and $sev -lt $gate -and $gate -ge 4) { $lvl = $min ; $sev = $gate}
        # Drop below gate
        if ($sev -lt $gate) { return }
        # Timestamp
        $ts = ([DateTime]::UtcNow).ToString('yyyy-MM-dd HH:mm:ss:fff')
        # Resolve caller: prefer "caller of org func" (grandparent of helper)
        $stack      = Get-PSCallStack
        $helperName = $MyInvocation.MyCommand.Name
        $orgFunc    = $null
        $caller     = $null
        if ($stack) {
            $orgIdx = -1;
            for ($i = 0; $i -lt $stack.Count; $i++) { if ($stack[$i].FunctionName -ne $helperName) { $orgFunc = $stack[$i]; $orgIdx = $i; break; }}
            if ($orgIdx -ge 0) { $callerIdx = $orgIdx + 1; if ($stack.Count -gt $callerIdx) { $caller = $stack[$callerIdx]; } else { $caller = $orgFunc; } }
        }
        if (-not $caller) { $caller = [pscustomobject]@{ ScriptName = $PSCommandPath; FunctionName = '<scriptblock>' }; }
        $file = if ($caller.ScriptName) { Split-Path -Leaf $caller.ScriptName } else { 'console' }
        $func = if ($caller.FunctionName) { $caller.FunctionName } else { '<scriptblock>' }
        # Keep original casing (no .ToLower()) to match definition casing
        $line = "[{0} {1}] [{2}] [{3}] {4}" -f $ts, $lvl, $file, $func, $Message
        # Emit: Output for non-errors; Error for ERR/FTL. Termination via $ErrorActionPreference.
        if ($sev -ge 4) {
            if ($ErrorActionPreference -eq 'Stop') {
                Write-Error -Message $line -ErrorId ("ConsoleLog.{0}" -f $lvl) -Category NotSpecified -ErrorAction Stop
            } else {
                Write-Error -Message $line -ErrorId ("ConsoleLog.{0}" -f $lvl) -Category NotSpecified
            }
        } else {
            Write-Information -MessageData $line -InformationAction Continue
        }
    }

   Examples:
   _Write-StandardMessage -Message "Loaded Replace-FilePlaceholders function."

   try {
      throw "Test error"
   }
   catch {
      _Write-StandardMessage -Message "$($_.PSMessageDetails)" -Level ERR  # Format $_. output properly  
   }

9) IDEMPOTENCY
   - FUNCTIONS MUST be idempotent: repeated runs converge to the same state without errors or drift.

10) DOCUMENTATION
    - PROVIDE comment-based help: Synopsis, Description, Parameters, Examples, Notes.
    - Examples should cover all relevant case dont serveral if applicable, no examples that are possible but do not make sense.

11) TEXT & STYLE
    - KEEP code ASCII-only.
    - KEEP implementations lean, readable, and reviewer-friendly (brief inline comments from an external reviewer’s perspective).
    
12) SYNTAX
    - Enforced ternary ban: Submissions MUST NOT contain the C-style ternary pattern ? : anywhere use if else instead.
    - Double-check for C-style ternary operators—the pattern is easy to overlook because it feels natural (cond ? a : b), ? : should be if { } else { }, every ? need to be checked.
    - If $null comparisons are used, $null should be on the left side of equality comparisons. 

13) BEHAVIOR 
    - Do not make changes that a not requested, if you spot a previous error write a statement about it in the end.

14) INLINE HELPERS (SAFE MODE)
    - SCOPE: Inline (nested) helpers defined with function MUST be created in the local scope: function _Name { ... }.
    - NAMING: Use a distinct prefix to avoid collisions, e.g. _ (example: function _Norm-List { [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")] param(...params...) ...code... }). PSUseApprovedVerbs needs to be between funcname and param.
    - COMMON PROBLEMS: Don't forget [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")] in inline helper functions.
    - NO OUTPUT: Helpers MUST NOT write to the pipeline. If needed, return values explicitly and keep them inside the outer function.
    - QUIET LOGGING: Helpers MUST NOT use Write-Output, Write-Error, Write-Verbose, or Write-Information. Use Write-Host only in the outer function for key actions.
    - NO EXPORT: Inline helpers MUST NOT be exported; they exist only for the duration of the outer function call.
    - IDEMPOTENT: Helpers MUST NOT rely on session-global state; they must be deterministic given their inputs.

15) Assume StrictMode-safe 3 is active before the function call; the function must be StrictMode-safe 3.
   - Forbid references to uninitialized variables, including inside strings.
   - Forbid references to non-existent object properties.
   - Forbid function calls that use method-call syntax.
   - Forbid out-of-bounds or unresolved array indices.
   - Definitive: The function must fully comply with StrictMode-safe 3.

16) COMPARISONS
   - ($null -ne $ext) $null should always be on the left side of the comparisons.

DEFINITE: A function is "DONE" only if it meets ALL requirements above.

