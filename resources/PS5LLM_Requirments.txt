GENERAL POWERSHELL REQUIREMENTS (APPLY TO ALL FUNCTIONS)

1) COMPATIBILITY
   - MUST run on Windows PowerShell 5/5.1 and PowerShell 7+ on Windows/macOS/Linux.

2) AUTOMATIC / RESERVED VARIABLES (PS5–PS7)
   - Do not read/write/compare or shadow PowerShell automatic/reserved vars (any casing). Examples (not exhaustive): $_, $PSItem, $args/$Args, $IsWindows/$IsMacOS/$IsLinux, $Error, $PID, $LASTEXITCODE, $Matches, $PSBoundParameters, $PSScriptRoot, $MyInvocation. Do not name parameters/locals like these (no "Args", "IsWindows", "Error", etc.).

3) EXTERNAL TOOLS
   - IF an external tool is required (e.g., dotnet, robocopy), THEN fail fast with a clear, actionable error when it is missing.

4) NAMING 
   - USE ONLY PS5/5.1 approved verbs.
   - PREFER singular nouns (plural may be an alias, not the primary noun).

5) SHOULDPROCESS / PIPELINE
   - DO NOT include SupportsShouldProcess; DO NOT implement -WhatIf or -Confirm.
   - DO NOT use ValueFromPipeline or ValueFromPipelineByPropertyName.

6) FLAGS & POLICY PARAMETERS
   - AVOID default-true switches for policy/behavior.
   - USE [ValidateSet()] string parameters instead (e.g., InstallationPolicy 'Trusted'|'Untrusted', State 'Enabled'|'Disabled').

7) ERROR BEHAVIOR
   - ASSUME caller may set $ErrorActionPreference = 'Stop'.
   - USE try/catch only where it adds value; rethrow with concise, actionable messages.

8) OUTPUT & LOGGING
   - EMIT Write- or _Write-StandardMessage ONLY for key actions (created X, added/removed Y, enabled/disabled Z, updated trust). Keep minimal and consistent.
   - Format the Write function implement a inline helper function for it suggested format.
      function _Write-StandardMessage {
         [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")]
         # This function has exceptions from the rest of any ruleset.
         [CmdletBinding()]
         param(
            [Parameter(Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [string]$Message,
            [Parameter(Mandatory=$false)]
            [ValidateSet('TRC','DBG','INF','WRN','ERR','FTL')]
            [string]$Level = 'INF',
            [Parameter(Mandatory=$false)]
            [ValidateSet('TRC','DBG','INF','WRN','ERR','FTL')]
            [string]$MinLevel
         )
         # Resolve MinLevel: explicit > global > default.
         if (-not $PSBoundParameters.ContainsKey('MinLevel')) {
            $MinLevel = if ($Global:ConsoleLogMinLevel) { $Global:ConsoleLogMinLevel } else { 'INF' }
         }
         $sevMap = @{ TRC=0; DBG=1; INF=2; WRN=3; ERR=4; FTL=5 }
         $lvl = $Level.ToUpperInvariant() ; $min = $MinLevel.ToUpperInvariant() ; $sev = $sevMap[$lvl] ; $gate= $sevMap[$min]
         # Auto-escalate requested errors to meet strict MinLevel (e.g., MinLevel=FTL)
         if ($sev -ge 4 -and $sev -lt $gate -and $gate -ge 4) { $lvl = $min ; $sev = $gate}
         # Drop below gate
         if ($sev -lt $gate) { return }
         # Format line
         $now = [DateTime]::UtcNow ; $ts  = $now.ToString('yyyy-MM-dd HH:mm:ss:fff')
         # Resolve caller (external reviewer perspective)
         $caller = Get-PSCallStack | Where-Object { $_.FunctionName -ne $MyInvocation.MyCommand.Name } | Select-Object -First 1
         if (-not $caller) { $caller = [pscustomobject]@{ ScriptName=$PSCommandPath; FunctionName='<scriptblock>' } }
         $file = if ($caller.ScriptName) { Split-Path -Leaf $caller.ScriptName } else { 'console' }
         $func = if ($caller.FunctionName) { $caller.FunctionName } else { '<scriptblock>' }
         $line = "[{0} {1}] [{2}] [{3}] {4}" -f $ts, $lvl, $file, $func.ToLower(), $Message
         # Emit: Output for non-errors; Error for ERR/FTL. Termination via $ErrorActionPreference.
         if ($sev -ge 4) {
            if ($ErrorActionPreference -eq 'Stop') {
                  Write-Error -Message $line -ErrorId ("ConsoleLog.{0}" -f $lvl) -Category NotSpecified -ErrorAction Stop
            } else {
                  Write-Error -Message $line -ErrorId ("ConsoleLog.{0}" -f $lvl) -Category NotSpecified
            }
         } else {
            Write-Information -MessageData $line -InformationAction Continue
         }
      }

   Examples:
   _Write-StandardMessage -Message "Loaded Replace-FilePlaceholders function."

   try {
      throw "Test error"
   }
   catch {
      _Write-StandardMessage -Message "$($_.PSMessageDetails)" -Level ERR  # Format $_. output properly  
   }

9) IDEMPOTENCY
   - FUNCTIONS MUST be idempotent: repeated runs converge to the same state without errors or drift.

10) DOCUMENTATION
    - PROVIDE comment-based help: Synopsis, Description, Parameters, Examples, Notes.
    - Examples should cover all relevant case dont serveral if applicable, no examples that are possible but do not make sense.

11) TEXT & STYLE
    - KEEP code ASCII-only.
    - KEEP implementations lean, readable, and reviewer-friendly (brief inline comments from an external reviewer’s perspective).
    
12) SYNTAX
    - Enforced ternary ban: Submissions MUST NOT contain the C-style ternary pattern ? : anywhere use if else instead.
    - Double-check for C-style ternary operators—the pattern is easy to overlook because it feels natural (cond ? a : b), ? : should be if { } else { }, every ? need to be checked.
    - If $null comparisons are used, $null should be on the left side of equality comparisons. 

13) BEHAVIOR 
    - Do not make changes that a not requested, if you spot a previous error write a statement about it in the end.

14) INLINE HELPERS (SAFE MODE)
    - SCOPE: Inline (nested) helpers defined with function MUST be created in the local scope: function _Name { ... }.
    - NAMING: Use a distinct prefix to avoid collisions, e.g. _ (example: function _Norm-List { [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")] param(...params...) ...code... }). PSUseApprovedVerbs needs to be between funcname and param.
    - COMMON PROBLEMS: Don't forget [Diagnostics.CodeAnalysis.SuppressMessage("PSUseApprovedVerbs","")] in inline helper functions.
    - NO OUTPUT: Helpers MUST NOT write to the pipeline. If needed, return values explicitly and keep them inside the outer function.
    - QUIET LOGGING: Helpers MUST NOT use Write-Output, Write-Error, Write-Verbose, or Write-Information. Use Write-Host only in the outer function for key actions.
    - NO EXPORT: Inline helpers MUST NOT be exported; they exist only for the duration of the outer function call.
    - IDEMPOTENT: Helpers MUST NOT rely on session-global state; they must be deterministic given their inputs.

15) Assume StrictMode-safe 3 is active before the function call; the function must be StrictMode-safe 3.
   - Forbid references to uninitialized variables, including inside strings.
   - Forbid references to non-existent object properties.
   - Forbid function calls that use method-call syntax.
   - Forbid out-of-bounds or unresolved array indices.
   - Definitive: The function must fully comply with StrictMode-safe 3.

DEFINITE: A function is "DONE" only if it meets ALL requirements above.

